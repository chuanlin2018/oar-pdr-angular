{"ast":null,"code":"import { __decorate, __metadata, __param } from 'tslib';\nimport { TemplateRef, Directive, EventEmitter, ContentChild, Input, Output, HostBinding, Component, forwardRef, ContentChildren, QueryList, Host, Optional, HostListener, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n/**\n * The `awWizardStepSymbol` directive can be used as an alternative to the `navigationSymbol` input of a [[WizardStep]]\n * to define the step symbol inside the navigation bar.  This way step symbol may contain arbitrary content.\n *\n * ### Syntax\n *\n * ```html\n * <ng-template awWizardStepSymbol>\n *     ...\n * </ng-template>\n * ```\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nconst _c0 = [\"*\"];\n\nconst _c1 = function (a0, a1, a2, a3, a4, a5, a6) {\n  return {\n    \"vertical\": a0,\n    \"horizontal\": a1,\n    \"small\": a2,\n    \"large-filled\": a3,\n    \"large-filled-symbols\": a4,\n    \"large-empty\": a5,\n    \"large-empty-symbols\": a6\n  };\n};\n\nfunction WizardComponent_aw_wizard_navigation_bar_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"aw-wizard-navigation-bar\", 2);\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"direction\", ctx_r0.navBarDirection)(\"ngClass\", ɵngcc0.ɵɵpureFunction7(2, _c1, ctx_r0.navBarLocation == \"left\", ctx_r0.navBarLocation == \"top\", ctx_r0.navBarLayout == \"small\", ctx_r0.navBarLayout == \"large-filled\", ctx_r0.navBarLayout == \"large-filled-symbols\", ctx_r0.navBarLayout == \"large-empty\", ctx_r0.navBarLayout == \"large-empty-symbols\"));\n  }\n}\n\nfunction WizardComponent_aw_wizard_navigation_bar_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"aw-wizard-navigation-bar\", 2);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"direction\", ctx_r1.navBarDirection)(\"ngClass\", ɵngcc0.ɵɵpureFunction7(2, _c1, ctx_r1.navBarLocation == \"right\", ctx_r1.navBarLocation == \"bottom\", ctx_r1.navBarLayout == \"small\", ctx_r1.navBarLayout == \"large-filled\", ctx_r1.navBarLayout == \"large-filled-symbols\", ctx_r1.navBarLayout == \"large-empty\", ctx_r1.navBarLayout == \"large-empty-symbols\"));\n  }\n}\n\nconst _c2 = function (a1, a2) {\n  return {\n    \"wizard-steps\": true,\n    \"vertical\": a1,\n    \"horizontal\": a2\n  };\n};\n\nconst _c3 = function (a0) {\n  return {\n    wizardStep: a0\n  };\n};\n\nfunction WizardNavigationBarComponent_li_1_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainer(0, 7);\n  }\n\n  if (rf & 2) {\n    const step_r1 = ɵngcc0.ɵɵnextContext().$implicit;\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", step_r1.stepTitleTemplate.templateRef)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(2, _c3, step_r1));\n  }\n}\n\nfunction WizardNavigationBarComponent_li_1_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const step_r1 = ɵngcc0.ɵɵnextContext().$implicit;\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(step_r1.stepTitle);\n  }\n}\n\nfunction WizardNavigationBarComponent_li_1_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainer(0, 7);\n  }\n\n  if (rf & 2) {\n    const step_r1 = ɵngcc0.ɵɵnextContext().$implicit;\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", step_r1.stepSymbolTemplate.templateRef)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(2, _c3, step_r1));\n  }\n}\n\nfunction WizardNavigationBarComponent_li_1_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const step_r1 = ɵngcc0.ɵɵnextContext().$implicit;\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(step_r1.navigationSymbol.symbol);\n  }\n}\n\nconst _c4 = function (a0, a1, a2, a3, a4, a5) {\n  return {\n    \"current\": a0,\n    \"editing\": a1,\n    \"done\": a2,\n    \"optional\": a3,\n    \"completed\": a4,\n    \"navigable\": a5\n  };\n};\n\nconst _c5 = function (a0) {\n  return {\n    \"font-family\": a0\n  };\n};\n\nfunction WizardNavigationBarComponent_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"li\", 1)(1, \"a\", 2)(2, \"div\", 3);\n    ɵngcc0.ɵɵtemplate(3, WizardNavigationBarComponent_li_1_ng_container_3_Template, 1, 4, \"ng-container\", 4);\n    ɵngcc0.ɵɵtemplate(4, WizardNavigationBarComponent_li_1_ng_container_4_Template, 2, 1, \"ng-container\", 5);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementStart(5, \"div\", 6);\n    ɵngcc0.ɵɵtemplate(6, WizardNavigationBarComponent_li_1_ng_container_6_Template, 1, 4, \"ng-container\", 4);\n    ɵngcc0.ɵɵtemplate(7, WizardNavigationBarComponent_li_1_ng_container_7_Template, 2, 1, \"ng-container\", 5);\n    ɵngcc0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const step_r1 = ctx.$implicit;\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction6(8, _c4, ctx_r0.isCurrent(step_r1), ctx_r0.isEditing(step_r1), ctx_r0.isDone(step_r1), ctx_r0.isOptional(step_r1), ctx_r0.isCompleted(step_r1), ctx_r0.isNavigable(step_r1)));\n    ɵngcc0.ɵɵattribute(\"id\", step_r1.stepId);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"awGoToStep\", step_r1);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngIf\", step_r1.stepTitleTemplate);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !step_r1.stepTitleTemplate);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngStyle\", ɵngcc0.ɵɵpureFunction1(15, _c5, step_r1.stepSymbolTemplate ? \"\" : step_r1.navigationSymbol.fontFamily));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", step_r1.stepSymbolTemplate);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !step_r1.stepSymbolTemplate);\n  }\n}\n\nlet WizardStepSymbolDirective = /*#__PURE__*/(() => {\n  let WizardStepSymbolDirective = class WizardStepSymbolDirective {\n    /**\n     * Constructor\n     *\n     * @param templateRef A reference to the content of the `ng-template` that contains this [[WizardStepSymbolDirective]]\n     */\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  };\n\n  WizardStepSymbolDirective.ɵfac = function WizardStepSymbolDirective_Factory(t) {\n    return new (t || WizardStepSymbolDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef));\n  };\n\n  WizardStepSymbolDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: WizardStepSymbolDirective,\n    selectors: [[\"ng-template\", \"awStepSymbol\", \"\"], [\"ng-template\", \"awWizardStepSymbol\", \"\"]]\n  });\n  WizardStepSymbolDirective = __decorate([__metadata(\"design:paramtypes\", [TemplateRef])], WizardStepSymbolDirective);\n  /**\n   * The `awWizardStepTitle` directive can be used as an alternative to the `stepTitle` input of a [[WizardStep]]\n   * to define the content of a step title inside the navigation bar.\n   * This step title can be freely created and can contain more than only plain text\n   *\n   * ### Syntax\n   *\n   * ```html\n   * <ng-template awWizardStepTitle>\n   *     ...\n   * </ng-template>\n   * ```\n   *\n   * @author Marc Arndt\n   */\n\n  return WizardStepSymbolDirective;\n})();\nlet WizardStepTitleDirective = /*#__PURE__*/(() => {\n  let WizardStepTitleDirective = class WizardStepTitleDirective {\n    /**\n     * Constructor\n     *\n     * @param templateRef A reference to the content of the `ng-template` that contains this [[WizardStepTitleDirective]]\n     */\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n\n  };\n\n  WizardStepTitleDirective.ɵfac = function WizardStepTitleDirective_Factory(t) {\n    return new (t || WizardStepTitleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef));\n  };\n\n  WizardStepTitleDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: WizardStepTitleDirective,\n    selectors: [[\"ng-template\", \"awStepTitle\", \"\"], [\"ng-template\", \"awWizardStepTitle\", \"\"]]\n  });\n  WizardStepTitleDirective = __decorate([__metadata(\"design:paramtypes\", [TemplateRef])], WizardStepTitleDirective);\n  return WizardStepTitleDirective;\n})();\nvar WizardStep_1;\n/**\n * Basic functionality every type of wizard step needs to provide\n *\n * @author Marc Arndt\n */\n\nlet WizardStep = WizardStep_1 = class WizardStep {\n  constructor() {\n    /**\n     * A symbol property, which contains an optional symbol for the step inside the navigation bar.\n     * Takes effect when `stepSymbolTemplate` is not defined or null.\n     */\n    this.navigationSymbol = {\n      symbol: ''\n    };\n    /**\n     * A boolean describing if the wizard step is currently selected\n     */\n\n    this.selected = false;\n    /**\n     * A boolean describing if the wizard step has been completed\n     */\n\n    this.completed = false;\n    /**\n     * A boolean describing if the wizard step is shown as completed when the wizard is presented to the user\n     *\n     * Users will typically use `CompletedStepDirective` to set this flag\n     */\n\n    this.initiallyCompleted = false;\n    /**\n     * A boolean describing if the wizard step is being edited after being competed\n     *\n     * This flag can only be true when `selected` is true.\n     */\n\n    this.editing = false;\n    /**\n     * A boolean describing, if the wizard step should be selected by default, i.e. after the wizard has been initialized as the initial step\n     */\n\n    this.defaultSelected = false;\n    /**\n     * A boolean describing if the wizard step is an optional step\n     */\n\n    this.optional = false;\n    /**\n     * A function or boolean deciding, if this step can be entered\n     */\n\n    this.canEnter = true;\n    /**\n     * A function or boolean deciding, if this step can be exited\n     */\n\n    this.canExit = true;\n    /**\n     * This [[EventEmitter]] is called when the step is entered.\n     * The bound method should be used to do initialization work.\n     */\n\n    this.stepEnter = new EventEmitter();\n    /**\n     * This [[EventEmitter]] is called when the step is exited.\n     * The bound method can be used to do cleanup work.\n     */\n\n    this.stepExit = new EventEmitter();\n  }\n  /**\n   * Returns true if this wizard step should be visible to the user.\n   * If the step should be visible to the user false is returned, otherwise true\n   */\n\n\n  get hidden() {\n    return !this.selected;\n  }\n  /**\n   * This method returns true, if this wizard step can be transitioned with a given direction.\n   * Transitioned in this case means either entered or exited, depending on the given `condition` parameter.\n   *\n   * @param condition A condition variable, deciding if the step can be transitioned\n   * @param direction The direction in which this step should be transitioned\n   * @returns A [[Promise]] containing `true`, if this step can transitioned in the given direction\n   * @throws An `Error` is thrown if `condition` is neither a function nor a boolean\n   */\n\n\n  static canTransitionStep(condition, direction) {\n    if (typeof condition === typeof true) {\n      return Promise.resolve(condition);\n    } else if (condition instanceof Function) {\n      return Promise.resolve(condition(direction));\n    } else {\n      return Promise.reject(new Error(`Input value '${condition}' is neither a boolean nor a function`));\n    }\n  }\n  /**\n   * A function called when the step is entered\n   *\n   * @param direction The direction in which the step is entered\n   */\n\n\n  enter(direction) {\n    this.stepEnter.emit(direction);\n  }\n  /**\n   * A function called when the step is exited\n   *\n   * @param direction The direction in which the step is exited\n   */\n\n\n  exit(direction) {\n    this.stepExit.emit(direction);\n  }\n  /**\n   * This method returns true, if this wizard step can be entered from the given direction.\n   * Because this method depends on the value `canEnter`, it will throw an error, if `canEnter` is neither a boolean\n   * nor a function.\n   *\n   * @param direction The direction in which this step should be entered\n   * @returns A [[Promise]] containing `true`, if the step can be entered in the given direction, false otherwise\n   * @throws An `Error` is thrown if `anEnter` is neither a function nor a boolean\n   */\n\n\n  canEnterStep(direction) {\n    return WizardStep_1.canTransitionStep(this.canEnter, direction);\n  }\n  /**\n   * This method returns true, if this wizard step can be exited into given direction.\n   * Because this method depends on the value `canExit`, it will throw an error, if `canExit` is neither a boolean\n   * nor a function.\n   *\n   * @param direction The direction in which this step should be left\n   * @returns A [[Promise]] containing `true`, if the step can be exited in the given direction, false otherwise\n   * @throws An `Error` is thrown if `canExit` is neither a function nor a boolean\n   */\n\n\n  canExitStep(direction) {\n    return WizardStep_1.canTransitionStep(this.canExit, direction);\n  }\n\n};\n\nWizardStep.ɵfac = function WizardStep_Factory(t) {\n  return new (t || WizardStep)();\n};\n\nWizardStep.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: WizardStep,\n  contentQueries: function WizardStep_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵcontentQuery(dirIndex, WizardStepTitleDirective, 5);\n      ɵngcc0.ɵɵcontentQuery(dirIndex, WizardStepSymbolDirective, 5);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.stepTitleTemplate = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.stepSymbolTemplate = _t.first);\n    }\n  },\n  hostVars: 1,\n  hostBindings: function WizardStep_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      ɵngcc0.ɵɵhostProperty(\"hidden\", ctx.hidden);\n    }\n  },\n  inputs: {\n    navigationSymbol: \"navigationSymbol\",\n    canEnter: \"canEnter\",\n    canExit: \"canExit\",\n    stepId: \"stepId\",\n    stepTitle: \"stepTitle\"\n  },\n  outputs: {\n    stepEnter: \"stepEnter\",\n    stepExit: \"stepExit\"\n  }\n});\n\n__decorate([ContentChild(WizardStepTitleDirective), __metadata(\"design:type\", WizardStepTitleDirective)], WizardStep.prototype, \"stepTitleTemplate\", void 0);\n\n__decorate([ContentChild(WizardStepSymbolDirective), __metadata(\"design:type\", WizardStepSymbolDirective)], WizardStep.prototype, \"stepSymbolTemplate\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", String)], WizardStep.prototype, \"stepId\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", String)], WizardStep.prototype, \"stepTitle\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Object)], WizardStep.prototype, \"navigationSymbol\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Object)], WizardStep.prototype, \"canEnter\", void 0);\n\n__decorate([Input(), __metadata(\"design:type\", Object)], WizardStep.prototype, \"canExit\", void 0);\n\n__decorate([Output(), __metadata(\"design:type\", EventEmitter)], WizardStep.prototype, \"stepEnter\", void 0);\n\n__decorate([Output(), __metadata(\"design:type\", EventEmitter)], WizardStep.prototype, \"stepExit\", void 0);\n\n__decorate([HostBinding('hidden'), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [])], WizardStep.prototype, \"hidden\", null);\n/**\n * Basic functionality every wizard completion step needs to provide\n *\n * @author Marc Arndt\n */\n\n\nlet WizardCompletionStep = /*#__PURE__*/(() => {\n  let WizardCompletionStep = class WizardCompletionStep extends WizardStep {\n    constructor() {\n      super(...arguments);\n      /**\n       * @inheritDoc\n       */\n\n      this.stepExit = new EventEmitter();\n      /**\n       * @inheritDoc\n       */\n\n      this.canExit = false;\n    }\n    /**\n     * @inheritDoc\n     */\n\n\n    enter(direction) {\n      this.completed = true;\n      this.stepEnter.emit(direction);\n    }\n    /**\n     * @inheritDoc\n     */\n\n\n    exit(direction) {\n      // set this completion step as incomplete (unless it happens to be initiallyCompleted)\n      this.completed = this.initiallyCompleted;\n      this.stepExit.emit(direction);\n    }\n\n  };\n\n  WizardCompletionStep.ɵfac = /*@__PURE__*/function () {\n    let ɵWizardCompletionStep_BaseFactory;\n    return function WizardCompletionStep_Factory(t) {\n      return (ɵWizardCompletionStep_BaseFactory || (ɵWizardCompletionStep_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(WizardCompletionStep)))(t || WizardCompletionStep);\n    };\n  }();\n\n  WizardCompletionStep.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: WizardCompletionStep,\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return WizardCompletionStep;\n})();\nvar WizardCompletionStepComponent_1;\n/**\n * The `aw-wizard-completion-step` component can be used to define a completion/success step at the end of your wizard\n * After a `aw-wizard-completion-step` has been entered, it has the characteristic that the user is blocked from\n * leaving it again to a previous step.\n * In addition entering a `aw-wizard-completion-step` automatically sets the `aw-wizard` and all steps inside the `aw-wizard`\n * as completed.\n *\n * ### Syntax\n *\n * ```html\n * <aw-wizard-completion-step [stepTitle]=\"title of the wizard step\"\n *    [navigationSymbol]=\"{ symbol: 'navigation symbol', fontFamily: 'navigation symbol font family' }\"\n *    (stepEnter)=\"event emitter to be called when the wizard step is entered\"\n *    (stepExit)=\"event emitter to be called when the wizard step is exited\">\n *    ...\n * </aw-wizard-completion-step>\n * ```\n *\n * ### Example\n *\n * ```html\n * <aw-wizard-completion-step stepTitle=\"Step 1\" [navigationSymbol]=\"{ symbol: '1' }\">\n *    ...\n * </aw-wizard-completion-step>\n * ```\n *\n * With a navigation symbol from the `font-awesome` font:\n *\n * ```html\n * <aw-wizard-completion-step stepTitle=\"Step 1\" [navigationSymbol]=\"{ symbol: '&#xf1ba;', fontFamily: 'FontAwesome' }\">\n *    ...\n * </aw-wizard-completion-step>\n * ```\n *\n * @author Marc Arndt\n */\n\nlet WizardCompletionStepComponent = WizardCompletionStepComponent_1 = class WizardCompletionStepComponent extends WizardCompletionStep {};\n\nWizardCompletionStepComponent.ɵfac = /*@__PURE__*/function () {\n  let ɵWizardCompletionStepComponent_BaseFactory;\n  return function WizardCompletionStepComponent_Factory(t) {\n    return (ɵWizardCompletionStepComponent_BaseFactory || (ɵWizardCompletionStepComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(WizardCompletionStepComponent)))(t || WizardCompletionStepComponent);\n  };\n}();\n\nWizardCompletionStepComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: WizardCompletionStepComponent,\n  selectors: [[\"aw-wizard-completion-step\"]],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: WizardStep,\n    useExisting: forwardRef(() => WizardCompletionStepComponent_1)\n  }, {\n    provide: WizardCompletionStep,\n    useExisting: forwardRef(() => WizardCompletionStepComponent_1)\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature],\n  ngContentSelectors: _c0,\n  decls: 1,\n  vars: 0,\n  template: function WizardCompletionStepComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵprojectionDef();\n      ɵngcc0.ɵɵprojection(0);\n    }\n  },\n  encapsulation: 2\n});\n/**\n * The direction in which a step transition was made\n *\n * @author Marc Arndt\n */\n\n/**\n * This enum contains the different possible moving directions in which a wizard can be traversed\n *\n * @author Marc Arndt\n */\n\nvar MovingDirection = /*#__PURE__*/(() => {\n  (function (MovingDirection) {\n    /**\n     * A forward step transition\n     */\n    MovingDirection[MovingDirection[\"Forwards\"] = 0] = \"Forwards\";\n    /**\n     * A backward step transition\n     */\n\n    MovingDirection[MovingDirection[\"Backwards\"] = 1] = \"Backwards\";\n    /**\n     * No step transition was done\n     */\n\n    MovingDirection[MovingDirection[\"Stay\"] = 2] = \"Stay\";\n  })(MovingDirection || (MovingDirection = {}));\n\n  return MovingDirection;\n})();\n\n/**\n * Base implementation of [[NavigationMode]]\n *\n * Note: Built-in [[NavigationMode]] classes should be stateless, allowing the library user to easily create\n * an instance of a particular [[NavigationMode]] class and pass it to `<aw-wizard [navigationMode]=\"...\">`.\n *\n * @author Marc Arndt\n */\nclass BaseNavigationMode {\n  /**\n   * Checks, whether a wizard step, as defined by the given destination index, can be transitioned to.\n   *\n   * This method controls navigation by [[goToStep]], [[goToPreviousStep]], and [[goToNextStep]] directives.\n   * Navigation by navigation bar is governed by [[isNavigable]].\n   *\n   * In this implementation, a destination wizard step can be entered if:\n   * - it exists\n   * - the current step can be exited in the direction of the destination step\n   * - the destination step can be entered in the direction from the current step\n   *\n   * Subclasses can impose additional restrictions, see [[canTransitionToStep]].\n   *\n   * @param wizard The wizard component to operate on\n   * @param destinationIndex The index of the destination step\n   * @returns A [[Promise]] containing `true`, if the destination step can be transitioned to and `false` otherwise\n   */\n  canGoToStep(wizard, destinationIndex) {\n    const hasStep = wizard.hasStep(destinationIndex);\n    const movingDirection = wizard.getMovingDirection(destinationIndex);\n\n    const canExitCurrentStep = previous => {\n      return previous && wizard.currentStep.canExitStep(movingDirection);\n    };\n\n    const canEnterDestinationStep = previous => {\n      return previous && wizard.getStepAtIndex(destinationIndex).canEnterStep(movingDirection);\n    };\n\n    const canTransitionToStep = previous => {\n      return previous && this.canTransitionToStep(wizard, destinationIndex);\n    };\n\n    return Promise.resolve(hasStep).then(canTransitionToStep) // Apply user-defined checks at the end.  They can involve user interaction\n    // which is better to be avoided if navigation mode does not actually allow the transition\n    // (`canTransitionToStep` returns `false`).\n    .then(canExitCurrentStep).then(canEnterDestinationStep);\n  }\n  /**\n   * Imposes additional restrictions for `canGoToStep` in current navigation mode.\n   *\n   * The base implementation allows transition iff the given step is navigable from the navigation bar (see `isNavigable`).\n   * However, in some navigation modes `canTransitionToStep` can be more relaxed to allow navigation to certain steps\n   * by previous/next buttons, but not using the navigation bar.\n   *\n   * @param wizard The wizard component to operate on\n   * @param destinationIndex The index of the destination step\n   * @returns `true`, if the destination step can be transitioned to and `false` otherwise\n   */\n\n\n  canTransitionToStep(wizard, destinationIndex) {\n    return this.isNavigable(wizard, destinationIndex);\n  }\n  /**\n   * Tries to transition to the wizard step, as denoted by the given destination index.\n   *\n   * When entering the destination step, the following actions are done:\n   * - the old current step is set as completed\n   * - the old current step is set as unselected\n   * - the old current step is exited\n   * - the destination step is set as selected\n   * - the destination step is entered\n   *\n   * When the destination step couldn't be entered, the following actions are done:\n   * - the current step is exited and entered in the direction `MovingDirection.Stay`\n   *\n   * @param wizard The wizard component to operate on\n   * @param destinationIndex The index of the destination wizard step, which should be entered\n   * @param preFinalize An event emitter, to be called before the step has been transitioned\n   * @param postFinalize An event emitter, to be called after the step has been transitioned\n   */\n\n\n  goToStep(wizard, destinationIndex, preFinalize, postFinalize) {\n    this.canGoToStep(wizard, destinationIndex).then(navigationAllowed => {\n      if (navigationAllowed) {\n        // the current step can be exited in the given direction\n        const movingDirection = wizard.getMovingDirection(destinationIndex);\n        /* istanbul ignore if */\n\n        if (preFinalize) {\n          preFinalize.emit();\n        } // leave current step\n\n\n        wizard.currentStep.completed = true;\n        wizard.currentStep.exit(movingDirection);\n        wizard.currentStep.editing = false;\n        wizard.currentStep.selected = false;\n        this.transition(wizard, destinationIndex); // remember if the next step is already completed before entering it to properly set `editing` flag\n\n        const wasCompleted = wizard.completed || wizard.currentStep.completed; // go to next step\n\n        wizard.currentStep.enter(movingDirection);\n        wizard.currentStep.selected = true;\n\n        if (wasCompleted) {\n          wizard.currentStep.editing = true;\n        }\n        /* istanbul ignore if */\n\n\n        if (postFinalize) {\n          postFinalize.emit();\n        }\n      } else {\n        // if the current step can't be left, reenter the current step\n        wizard.currentStep.exit(MovingDirection.Stay);\n        wizard.currentStep.enter(MovingDirection.Stay);\n      }\n    });\n  }\n  /**\n   * Transitions the wizard to the given step index.\n   *\n   * Can perform additional actions in particular navigation mode implementations.\n   *\n   * @param wizard The wizard component to operate on\n   * @param destinationIndex The index of the destination wizard step\n   */\n\n\n  transition(wizard, destinationIndex) {\n    wizard.currentStepIndex = destinationIndex;\n  }\n  /**\n   * Resets the state of this wizard.\n   *\n   * A reset transitions the wizard automatically to the first step and sets all steps as incomplete.\n   * In addition the whole wizard is set as incomplete.\n   *\n   * @param wizard The wizard component to operate on\n   */\n\n\n  reset(wizard) {\n    this.ensureCanReset(wizard); // reset the step internal state\n\n    wizard.wizardSteps.forEach(step => {\n      step.completed = step.initiallyCompleted;\n      step.selected = false;\n      step.editing = false;\n    }); // set the first step as the current step\n\n    wizard.currentStepIndex = wizard.defaultStepIndex;\n    wizard.currentStep.selected = true;\n    wizard.currentStep.enter(MovingDirection.Forwards);\n  }\n  /**\n   * Checks if wizard configuration allows to perform reset.\n   *\n   * A check failure is indicated by throwing an `Error` with the message discribing the discovered misconfiguration issue.\n   *\n   * Can include additional checks in particular navigation mode implementations.\n   *\n   * @param wizard The wizard component to operate on\n   * @throws An `Error` is thrown, if a micconfiguration issue is discovered.\n   */\n\n\n  ensureCanReset(wizard) {\n    // the wizard doesn't contain a step with the default step index\n    if (!wizard.hasStep(wizard.defaultStepIndex)) {\n      throw new Error(`The wizard doesn't contain a step with index ${wizard.defaultStepIndex}`);\n    }\n  }\n\n}\n/**\n * The default navigation mode used by [[WizardComponent]] and [[NavigationModeDirective]].\n *\n * It is parameterized with two navigation policies passed to constructor:\n *\n * - [[navigateBackward]] policy controls whether wizard steps before the current step are navigable:\n *\n *   - `\"deny\"` -- the steps are not navigable\n *   - `\"allow\"` -- the steps are navigable\n *   - If the corresponding constructor argument is omitted or is `null` or `undefined`,\n *     then the default value is applied which is `\"deny\"`\n *\n * - [[navigateForward]] policy controls whether wizard steps after the current step are navigable:\n *\n *   - `\"deny\"` -- the steps are not navigable\n *   - `\"allow\"` -- the steps are navigable\n *   - `\"visited\"` -- a step is navigable iff it was already visited before\n *   - If the corresponding constructor argument is omitted or is `null` or `undefined`,\n *     then the default value is applied which is `\"allow\"`\n */\n\n\nclass ConfigurableNavigationMode extends BaseNavigationMode {\n  /**\n   * Constructor\n   *\n   * @param navigateBackward Controls whether wizard steps before the current step are navigable\n   * @param navigateForward Controls whether wizard steps before the current step are navigable\n   */\n  constructor(navigateBackward = null, navigateForward = null) {\n    super();\n    this.navigateBackward = navigateBackward;\n    this.navigateForward = navigateForward;\n    this.navigateBackward = this.navigateBackward || 'allow';\n    this.navigateForward = this.navigateForward || 'deny';\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  canTransitionToStep(wizard, destinationIndex) {\n    // if the destination step can be navigated to using the navigation bar,\n    // it should be accessible with [goToStep] as well\n    if (this.isNavigable(wizard, destinationIndex)) {\n      return true;\n    } // navigation with [goToStep] is permitted if all previous steps\n    // to the destination step have been completed or are optional\n\n\n    return wizard.wizardSteps.filter((step, index) => index < destinationIndex && index !== wizard.currentStepIndex).every(step => step.completed || step.optional);\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  transition(wizard, destinationIndex) {\n    if (this.navigateForward === 'deny') {\n      // set all steps after the destination step to incomplete\n      wizard.wizardSteps.filter((step, index) => wizard.currentStepIndex > destinationIndex && index > destinationIndex).forEach(step => step.completed = false);\n    }\n\n    super.transition(wizard, destinationIndex);\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  isNavigable(wizard, destinationIndex) {\n    // Check if the destination step can be navigated to\n    const destinationStep = wizard.getStepAtIndex(destinationIndex);\n\n    if (destinationStep instanceof WizardCompletionStep) {\n      // A completion step can only be entered, if all previous steps have been completed, are optional, or selected\n      const previousStepsCompleted = wizard.wizardSteps.filter((step, index) => index < destinationIndex).every(step => step.completed || step.optional || step.selected);\n\n      if (!previousStepsCompleted) {\n        return false;\n      }\n    } // Apply navigation pocicies\n\n\n    if (destinationIndex < wizard.currentStepIndex) {\n      // If the destination step is before current, apply the `navigateBackward` policy\n      switch (this.navigateBackward) {\n        case 'allow':\n          return true;\n\n        case 'deny':\n          return false;\n\n        default:\n          throw new Error(`Invalid value for navigateBackward: ${this.navigateBackward}`);\n      }\n    } else if (destinationIndex > wizard.currentStepIndex) {\n      // If the destination step is after current, apply the `navigateForward` policy\n      switch (this.navigateForward) {\n        case 'allow':\n          return true;\n\n        case 'deny':\n          return false;\n\n        case 'visited':\n          return destinationStep.completed;\n\n        default:\n          throw new Error(`Invalid value for navigateForward: ${this.navigateForward}`);\n      }\n    } else {\n      // Re-entering the current step is not allowed\n      return false;\n    }\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  ensureCanReset(wizard) {\n    super.ensureCanReset(wizard); // the default step is a completion step and the wizard contains more than one step\n\n    const defaultWizardStep = wizard.getStepAtIndex(wizard.defaultStepIndex);\n    const defaultCompletionStep = defaultWizardStep instanceof WizardCompletionStep;\n\n    if (defaultCompletionStep && wizard.wizardSteps.length !== 1) {\n      throw new Error(`The default step index ${wizard.defaultStepIndex} references a completion step`);\n    }\n  }\n\n}\n/**\n * The `aw-wizard` component defines the root component of a wizard.\n * Through the setting of input parameters for the `aw-wizard` component it's possible to change the location and size\n * of its navigation bar.\n *\n * ### Syntax\n * ```html\n * <aw-wizard [navBarLocation]=\"location of navigation bar\" [navBarLayout]=\"layout of navigation bar\">\n *     ...\n * </aw-wizard>\n * ```\n *\n * ### Example\n *\n * Without completion step:\n *\n * ```html\n * <aw-wizard navBarLocation=\"top\" navBarLayout=\"small\">\n *     <aw-wizard-step>...</aw-wizard-step>\n *     <aw-wizard-step>...</aw-wizard-step>\n * </aw-wizard>\n * ```\n *\n * With completion step:\n *\n * ```html\n * <aw-wizard navBarLocation=\"top\" navBarLayout=\"small\">\n *     <aw-wizard-step>...</aw-wizard-step>\n *     <aw-wizard-step>...</aw-wizard-step>\n *     <aw-wizard-completion-step>...</aw-wizard-completion-step>\n * </aw-wizard>\n * ```\n *\n * @author Marc Arndt\n */\n\n\nlet WizardComponent = /*#__PURE__*/(() => {\n  let WizardComponent = class WizardComponent {\n    /**\n     * Constructor\n     */\n    constructor() {\n      /**\n       * The location of the navigation bar inside the wizard.\n       * This location can be either top, bottom, left or right\n       */\n      this.navBarLocation = 'top';\n      /**\n       * The layout of the navigation bar inside the wizard.\n       * The layout can be either small, large-filled, large-empty or large-symbols\n       */\n\n      this.navBarLayout = 'small';\n      /**\n       * The direction in which the steps inside the navigation bar should be shown.\n       * The direction can be either `left-to-right` or `right-to-left`\n       */\n\n      this.navBarDirection = 'left-to-right';\n      this._defaultStepIndex = 0;\n      /**\n       * True, if the navigation bar shouldn't be used for navigating\n       */\n\n      this.disableNavigationBar = false;\n      /**\n       * The navigation mode used to navigate inside the wizard\n       *\n       * For outside access, use the [[navigation]] getter.\n       */\n\n      this._navigation = new ConfigurableNavigationMode();\n      /**\n       * An array representation of all wizard steps belonging to this model\n       *\n       * For outside access, use the [[wizardSteps]] getter.\n       */\n\n      this._wizardSteps = [];\n      /**\n       * The index of the currently visible and selected step inside the wizardSteps QueryList.\n       * If this wizard contains no steps, currentStepIndex is -1\n       *\n       * Note: Do not modify this field directly.  Instead, use navigation methods:\n       * [[goToStep]], [[goToPreviousStep]], [[goToNextStep]].\n       */\n\n      this.currentStepIndex = -1;\n    }\n    /**\n     * The initially selected step, represented by its index\n     * Beware: This initial default is only used if no wizard step has been enhanced with the `selected` directive\n     */\n\n\n    get defaultStepIndex() {\n      // This value can be either:\n      // - the index of a wizard step with a `selected` directive, or\n      // - the default step index, set in the [[WizardComponent]]\n      const foundDefaultStep = this.wizardSteps.find(step => step.defaultSelected);\n\n      if (foundDefaultStep) {\n        return this.getIndexOfStep(foundDefaultStep);\n      } else {\n        return this._defaultStepIndex;\n      }\n    }\n\n    set defaultStepIndex(defaultStepIndex) {\n      this._defaultStepIndex = defaultStepIndex;\n    }\n    /**\n     * Returns true if this wizard uses a horizontal orientation.\n     * The wizard uses a horizontal orientation, iff the navigation bar is shown at the top or bottom of this wizard\n     *\n     * @returns True if this wizard uses a horizontal orientation\n     */\n\n\n    get horizontalOrientation() {\n      return this.navBarLocation === 'top' || this.navBarLocation === 'bottom';\n    }\n    /**\n     * Returns true if this wizard uses a vertical orientation.\n     * The wizard uses a vertical orientation, iff the navigation bar is shown at the left or right of this wizard\n     *\n     * @returns True if this wizard uses a vertical orientation\n     */\n\n\n    get verticalOrientation() {\n      return this.navBarLocation === 'left' || this.navBarLocation === 'right';\n    }\n    /**\n     * Initialization work\n     */\n\n\n    ngAfterContentInit() {\n      // add a subscriber to the wizard steps QueryList to listen to changes in the DOM\n      this.wizardStepsQueryList.changes.subscribe(changedWizardSteps => {\n        this.updateWizardSteps(changedWizardSteps.toArray());\n      }); // initialize the model\n\n      this.updateWizardSteps(this.wizardStepsQueryList.toArray()); // finally reset the whole wizard component\n\n      setTimeout(() => this.reset());\n    }\n    /**\n     * The WizardStep object belonging to the currently visible and selected step.\n     * The currentStep is always the currently selected wizard step.\n     * The currentStep can be either completed, if it was visited earlier,\n     * or not completed, if it is visited for the first time or its state is currently out of date.\n     *\n     * If this wizard contains no steps, currentStep is null\n     */\n\n\n    get currentStep() {\n      if (this.hasStep(this.currentStepIndex)) {\n        return this.wizardSteps[this.currentStepIndex];\n      } else {\n        return null;\n      }\n    }\n    /**\n     * The completeness of the wizard.\n     * If the wizard has been completed, i.e. all steps are either completed or optional, this value is true, otherwise it is false\n     */\n\n\n    get completed() {\n      return this.wizardSteps.every(step => step.completed || step.optional);\n    }\n    /**\n     * An array representation of all wizard steps belonging to this model\n     */\n\n\n    get wizardSteps() {\n      return this._wizardSteps;\n    }\n    /**\n     * Updates the wizard steps to the new array\n     *\n     * @param wizardSteps The updated wizard steps\n     */\n\n\n    updateWizardSteps(wizardSteps) {\n      // the wizard is currently not in the initialization phase\n      if (this.wizardSteps.length > 0 && this.currentStepIndex > -1) {\n        this.currentStepIndex = wizardSteps.indexOf(this.wizardSteps[this.currentStepIndex]);\n      }\n\n      this._wizardSteps = wizardSteps;\n    }\n    /**\n     * The navigation mode used to navigate inside the wizard\n     */\n\n\n    get navigation() {\n      return this._navigation;\n    }\n    /**\n     * Updates the navigation mode for this wizard component\n     *\n     * @param navigation The updated navigation mode\n     */\n\n\n    set navigation(navigation) {\n      this._navigation = navigation;\n    }\n    /**\n     * Checks if a given index `stepIndex` is inside the range of possible wizard steps inside this wizard\n     *\n     * @param stepIndex The to be checked index of a step inside this wizard\n     * @returns True if the given `stepIndex` is contained inside this wizard, false otherwise\n     */\n\n\n    hasStep(stepIndex) {\n      return this.wizardSteps.length > 0 && 0 <= stepIndex && stepIndex < this.wizardSteps.length;\n    }\n    /**\n     * Checks if this wizard has a previous step, compared to the current step\n     *\n     * @returns True if this wizard has a previous step before the current step\n     */\n\n\n    hasPreviousStep() {\n      return this.hasStep(this.currentStepIndex - 1);\n    }\n    /**\n     * Checks if this wizard has a next step, compared to the current step\n     *\n     * @returns True if this wizard has a next step after the current step\n     */\n\n\n    hasNextStep() {\n      return this.hasStep(this.currentStepIndex + 1);\n    }\n    /**\n     * Checks if this wizard is currently inside its last step\n     *\n     * @returns True if the wizard is currently inside its last step\n     */\n\n\n    isLastStep() {\n      return this.wizardSteps.length > 0 && this.currentStepIndex === this.wizardSteps.length - 1;\n    }\n    /**\n     * Finds the [[WizardStep]] at the given index `stepIndex`.\n     * If no [[WizardStep]] exists at the given index an Error is thrown\n     *\n     * @param stepIndex The given index\n     * @returns The found [[WizardStep]] at the given index `stepIndex`\n     * @throws An `Error` is thrown, if the given index `stepIndex` doesn't exist\n     */\n\n\n    getStepAtIndex(stepIndex) {\n      if (!this.hasStep(stepIndex)) {\n        throw new Error(`Expected a known step, but got stepIndex: ${stepIndex}.`);\n      }\n\n      return this.wizardSteps[stepIndex];\n    }\n    /**\n     * Finds the index of the step with the given `stepId`.\n     * If no step with the given `stepId` exists, `-1` is returned\n     *\n     * @param stepId The given step id\n     * @returns The found index of a step with the given step id, or `-1` if no step with the given id is included in the wizard\n     */\n\n\n    getIndexOfStepWithId(stepId) {\n      return this.wizardSteps.findIndex(step => step.stepId === stepId);\n    }\n    /**\n     * Finds the index of the given [[WizardStep]] `step`.\n     * If the given [[WizardStep]] is not contained inside this wizard, `-1` is returned\n     *\n     * @param step The given [[WizardStep]]\n     * @returns The found index of `step` or `-1` if the step is not included in the wizard\n     */\n\n\n    getIndexOfStep(step) {\n      return this.wizardSteps.indexOf(step);\n    }\n    /**\n     * Calculates the correct [[MovingDirection]] value for a given `destinationStep` compared to the `currentStepIndex`.\n     *\n     * @param destinationStep The given destination step\n     * @returns The calculated [[MovingDirection]]\n     */\n\n\n    getMovingDirection(destinationStep) {\n      let movingDirection;\n\n      if (destinationStep > this.currentStepIndex) {\n        movingDirection = MovingDirection.Forwards;\n      } else if (destinationStep < this.currentStepIndex) {\n        movingDirection = MovingDirection.Backwards;\n      } else {\n        movingDirection = MovingDirection.Stay;\n      }\n\n      return movingDirection;\n    }\n    /**\n     * Checks, whether a wizard step, as defined by the given destination index, can be transitioned to.\n     *\n     * This method controls navigation by [[goToStep]], [[goToPreviousStep]], and [[goToNextStep]] directives.\n     * Navigation by navigation bar is governed by [[isNavigable]].\n     *\n     * @param destinationIndex The index of the destination step\n     * @returns A [[Promise]] containing `true`, if the destination step can be transitioned to and false otherwise\n     */\n\n\n    canGoToStep(destinationIndex) {\n      return this.navigation.canGoToStep(this, destinationIndex);\n    }\n    /**\n     * Tries to transition to the wizard step, as denoted by the given destination index.\n     *\n     * Note: You do not have to call [[canGoToStep]] before calling [[goToStep]].\n     * The [[canGoToStep]] method will be called automatically.\n     *\n     * @param destinationIndex The index of the destination wizard step, which should be entered\n     * @param preFinalize An event emitter, to be called before the step has been transitioned\n     * @param postFinalize An event emitter, to be called after the step has been transitioned\n     */\n\n\n    goToStep(destinationIndex, preFinalize, postFinalize) {\n      return this.navigation.goToStep(this, destinationIndex, preFinalize, postFinalize);\n    }\n    /**\n     * Tries to transition the wizard to the previous step\n     *\n     * @param preFinalize An event emitter, to be called before the step has been transitioned\n     * @param postFinalize An event emitter, to be called after the step has been transitioned\n     */\n\n\n    goToPreviousStep(preFinalize, postFinalize) {\n      return this.navigation.goToStep(this, this.currentStepIndex - 1, preFinalize, postFinalize);\n    }\n    /**\n     * Tries to transition the wizard to the next step\n     *\n     * @param preFinalize An event emitter, to be called before the step has been transitioned\n     * @param postFinalize An event emitter, to be called after the step has been transitioned\n     */\n\n\n    goToNextStep(preFinalize, postFinalize) {\n      return this.navigation.goToStep(this, this.currentStepIndex + 1, preFinalize, postFinalize);\n    }\n    /**\n     * Checks, whether the wizard step, located at the given index, can be navigated to using the navigation bar.\n     *\n     * @param destinationIndex The index of the destination step\n     * @returns True if the step can be navigated to, false otherwise\n     */\n\n\n    isNavigable(destinationIndex) {\n      return this.navigation.isNavigable(this, destinationIndex);\n    }\n    /**\n     * Resets the state of this wizard.\n     */\n\n\n    reset() {\n      this.navigation.reset(this);\n    }\n\n  };\n\n  WizardComponent.ɵfac = function WizardComponent_Factory(t) {\n    return new (t || WizardComponent)();\n  };\n\n  WizardComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: WizardComponent,\n    selectors: [[\"aw-wizard\"]],\n    contentQueries: function WizardComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, WizardStep, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.wizardStepsQueryList = _t);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function WizardComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"horizontal\", ctx.horizontalOrientation)(\"vertical\", ctx.verticalOrientation);\n      }\n    },\n    inputs: {\n      navBarLocation: \"navBarLocation\",\n      navBarLayout: \"navBarLayout\",\n      navBarDirection: \"navBarDirection\",\n      disableNavigationBar: \"disableNavigationBar\",\n      defaultStepIndex: \"defaultStepIndex\"\n    },\n    ngContentSelectors: _c0,\n    decls: 4,\n    vars: 6,\n    consts: [[3, \"direction\", \"ngClass\", 4, \"ngIf\"], [3, \"ngClass\"], [3, \"direction\", \"ngClass\"]],\n    template: function WizardComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, WizardComponent_aw_wizard_navigation_bar_0_Template, 1, 10, \"aw-wizard-navigation-bar\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"div\", 1);\n        ɵngcc0.ɵɵprojection(2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(3, WizardComponent_aw_wizard_navigation_bar_3_Template, 1, 10, \"aw-wizard-navigation-bar\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.navBarLocation == \"top\" || ctx.navBarLocation == \"left\");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction2(3, _c2, ctx.navBarLocation == \"left\" || ctx.navBarLocation == \"right\", ctx.navBarLocation == \"top\" || ctx.navBarLocation == \"bottom\"));\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.navBarLocation == \"bottom\" || ctx.navBarLocation == \"right\");\n      }\n    },\n    directives: function () {\n      return [ɵngcc1.NgIf, WizardNavigationBarComponent, ɵngcc1.NgClass];\n    },\n    encapsulation: 2\n  });\n\n  __decorate([ContentChildren(WizardStep, {\n    descendants: true\n  }), __metadata(\"design:type\", QueryList)], WizardComponent.prototype, \"wizardStepsQueryList\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], WizardComponent.prototype, \"navBarLocation\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], WizardComponent.prototype, \"navBarLayout\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], WizardComponent.prototype, \"navBarDirection\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", Number), __metadata(\"design:paramtypes\", [Number])], WizardComponent.prototype, \"defaultStepIndex\", null);\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], WizardComponent.prototype, \"disableNavigationBar\", void 0);\n\n  __decorate([HostBinding('class.horizontal'), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [])], WizardComponent.prototype, \"horizontalOrientation\", null);\n\n  __decorate([HostBinding('class.vertical'), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [])], WizardComponent.prototype, \"verticalOrientation\", null);\n\n  WizardComponent = __decorate([__metadata(\"design:paramtypes\", [])], WizardComponent);\n  /**\n   * The `aw-wizard-navigation-bar` component contains the navigation bar inside a [[WizardComponent]].\n   * To correctly display the navigation bar, it's required to set the right css classes for the navigation bar,\n   * otherwise it will look like a normal `ul` component.\n   *\n   * ### Syntax\n   *\n   * ```html\n   * <aw-wizard-navigation-bar></aw-wizard-navigation-bar>\n   * ```\n   *\n   * @author Marc Arndt\n   */\n\n  return WizardComponent;\n})();\nlet WizardNavigationBarComponent = /*#__PURE__*/(() => {\n  let WizardNavigationBarComponent = class WizardNavigationBarComponent {\n    /**\n     * Constructor\n     *\n     * @param wizard The state the wizard currently resides in\n     */\n    constructor(wizard) {\n      this.wizard = wizard;\n      /**\n       * The direction in which the wizard steps should be shown in the navigation bar.\n       * This value can be either `left-to-right` or `right-to-left`\n       */\n\n      this.direction = 'left-to-right';\n    }\n    /**\n     * Returns all [[WizardStep]]s contained in the wizard\n     *\n     * @returns An array containing all [[WizardStep]]s\n     */\n\n\n    get wizardSteps() {\n      switch (this.direction) {\n        case 'right-to-left':\n          return this.wizard.wizardSteps.slice().reverse();\n\n        case 'left-to-right':\n        default:\n          return this.wizard.wizardSteps;\n      }\n    }\n    /**\n     * Returns the number of wizard steps, that need to be displaced in the navigation bar\n     *\n     * @returns The number of wizard steps to be displayed\n     */\n\n\n    get numberOfWizardSteps() {\n      return this.wizard.wizardSteps.length;\n    }\n    /**\n     * Checks, whether a [[WizardStep]] can be marked as `current` in the navigation bar\n     *\n     * @param wizardStep The wizard step to be checked\n     * @returns True if the step can be marked as `current`\n     */\n\n\n    isCurrent(wizardStep) {\n      return wizardStep.selected;\n    }\n    /**\n     * Checks, whether a [[WizardStep]] can be marked as `editing` in the navigation bar\n     *\n     * @param wizardStep The wizard step to be checked\n     * @returns True if the step can be marked as `editing`\n     */\n\n\n    isEditing(wizardStep) {\n      return wizardStep.editing;\n    }\n    /**\n     * Checks, whether a [[WizardStep]] can be marked as `done` in the navigation bar\n     *\n     * @param wizardStep The wizard step to be checked\n     * @returns True if the step can be marked as `done`\n     */\n\n\n    isDone(wizardStep) {\n      return wizardStep.completed;\n    }\n    /**\n     * Checks, whether a [[WizardStep]] can be marked as `optional` in the navigation bar\n     *\n     * @param wizardStep The wizard step to be checked\n     * @returns True if the step can be marked as `optional`\n     */\n\n\n    isOptional(wizardStep) {\n      return wizardStep.optional;\n    }\n    /**\n     * Checks, whether a [[WizardStep]] can be marked as `completed` in the navigation bar.\n     *\n     * The `completed` class is only applied to completion steps.\n     *\n     * @param wizardStep The wizard step to be checked\n     * @returns True if the step can be marked as `completed`\n     */\n\n\n    isCompleted(wizardStep) {\n      return wizardStep instanceof WizardCompletionStep && this.wizard.completed;\n    }\n    /**\n     * Checks, whether a [[WizardStep]] can be marked as `navigable` in the navigation bar.\n     * A wizard step can be navigated to if:\n     * - the step is currently not selected\n     * - the navigation bar isn't disabled\n     * - the navigation mode allows navigation to the step\n     *\n     * @param wizardStep The wizard step to be checked\n     * @returns True if the step can be marked as navigable\n     */\n\n\n    isNavigable(wizardStep) {\n      return !wizardStep.selected && !this.wizard.disableNavigationBar && this.wizard.isNavigable(this.wizard.getIndexOfStep(wizardStep));\n    }\n\n  };\n\n  WizardNavigationBarComponent.ɵfac = function WizardNavigationBarComponent_Factory(t) {\n    return new (t || WizardNavigationBarComponent)(ɵngcc0.ɵɵdirectiveInject(WizardComponent));\n  };\n\n  WizardNavigationBarComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: WizardNavigationBarComponent,\n    selectors: [[\"aw-wizard-navigation-bar\"]],\n    inputs: {\n      direction: \"direction\"\n    },\n    decls: 2,\n    vars: 4,\n    consts: [[3, \"ngClass\", 4, \"ngFor\", \"ngForOf\"], [3, \"ngClass\"], [3, \"awGoToStep\"], [1, \"label\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\", 4, \"ngIf\"], [4, \"ngIf\"], [1, \"step-indicator\", 3, \"ngStyle\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function WizardNavigationBarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"ul\");\n        ɵngcc0.ɵɵtemplate(1, WizardNavigationBarComponent_li_1_Template, 8, 17, \"li\", 0);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassMapInterpolate1(\"steps-indicator steps-\", ctx.numberOfWizardSteps, \"\");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.wizardSteps);\n      }\n    },\n    directives: function () {\n      return [ɵngcc1.NgForOf, ɵngcc1.NgClass, GoToStepDirective, ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, ɵngcc1.NgStyle];\n    },\n    encapsulation: 2\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], WizardNavigationBarComponent.prototype, \"direction\", void 0);\n\n  WizardNavigationBarComponent = __decorate([__metadata(\"design:paramtypes\", [WizardComponent])], WizardNavigationBarComponent);\n  return WizardNavigationBarComponent;\n})();\nvar WizardStepComponent_1;\n/**\n * The `aw-wizard-step` component is used to define a normal step inside a wizard.\n *\n * ### Syntax\n *\n * With `stepTitle` and `navigationSymbol` inputs:\n *\n * ```html\n * <aw-wizard-step [stepTitle]=\"step title\" [navigationSymbol]=\"{ symbol: 'symbol', fontFamily: 'font-family' }\"\n *    [canExit]=\"deciding function\" (stepEnter)=\"enter function\" (stepExit)=\"exit function\">\n *    ...\n * </aw-wizard-step>\n * ```\n *\n * With `awWizardStepTitle` and `awWizardStepSymbol` directives:\n *\n * ```html\n * <aw-wizard-step\"\n *    [canExit]=\"deciding function\" (stepEnter)=\"enter function\" (stepExit)=\"exit function\">\n *    <ng-template awWizardStepTitle>\n *        step title\n *    </ng-template>\n *    <ng-template awWizardStepSymbol>\n *        symbol\n *    </ng-template>\n *    ...\n * </aw-wizard-step>\n * ```\n *\n * ### Example\n *\n * With `stepTitle` and `navigationSymbol` inputs:\n *\n * ```html\n * <aw-wizard-step stepTitle=\"Address information\" [navigationSymbol]=\"{ symbol: '&#xf1ba;', fontFamily: 'FontAwesome' }\">\n *    ...\n * </aw-wizard-step>\n * ```\n *\n * With `awWizardStepTitle` and `awWizardStepSymbol` directives:\n *\n * ```html\n * <aw-wizard-step>\n *    <ng-template awWizardStepTitle>\n *        Address information\n *    </ng-template>\n *    <ng-template awWizardStepSymbol>\n *        <i class=\"fa fa-taxi\"></i>\n *    </ng-template>\n * </aw-wizard-step>\n * ```\n *\n * @author Marc Arndt\n */\n\nlet WizardStepComponent = WizardStepComponent_1 = class WizardStepComponent extends WizardStep {};\n\nWizardStepComponent.ɵfac = /*@__PURE__*/function () {\n  let ɵWizardStepComponent_BaseFactory;\n  return function WizardStepComponent_Factory(t) {\n    return (ɵWizardStepComponent_BaseFactory || (ɵWizardStepComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(WizardStepComponent)))(t || WizardStepComponent);\n  };\n}();\n\nWizardStepComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: WizardStepComponent,\n  selectors: [[\"aw-wizard-step\"]],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: WizardStep,\n    useExisting: forwardRef(() => WizardStepComponent_1)\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature],\n  ngContentSelectors: _c0,\n  decls: 1,\n  vars: 0,\n  template: function WizardStepComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵprojectionDef();\n      ɵngcc0.ɵɵprojection(0);\n    }\n  },\n  encapsulation: 2\n});\n/**\n * The `awEnableBackLinks` directive can be used to allow the user to leave a [[WizardCompletionStep]] after is has been entered.\n *\n * ### Syntax\n *\n * ```html\n * <aw-wizard-completion-step awEnableBackLinks (stepExit)=\"exit function\">\n *     ...\n * </aw-wizard-completion-step>\n * ```\n *\n * ### Example\n *\n * ```html\n * <aw-wizard-completion-step stepTitle=\"Final step\" awEnableBackLinks>\n *     ...\n * </aw-wizard-completion-step>\n * ```\n *\n * @author Marc Arndt\n */\n\nlet EnableBackLinksDirective = /*#__PURE__*/(() => {\n  let EnableBackLinksDirective = class EnableBackLinksDirective {\n    /**\n     * Constructor\n     *\n     * @param completionStep The wizard completion step, which should be exitable\n     */\n    constructor(completionStep) {\n      this.completionStep = completionStep;\n      /**\n       * This EventEmitter is called when the step is exited.\n       * The bound method can be used to do cleanup work.\n       */\n\n      this.stepExit = new EventEmitter();\n    }\n    /**\n     * Initialization work\n     */\n\n\n    ngOnInit() {\n      this.completionStep.canExit = true;\n      this.completionStep.stepExit = this.stepExit;\n    }\n\n  };\n\n  EnableBackLinksDirective.ɵfac = function EnableBackLinksDirective_Factory(t) {\n    return new (t || EnableBackLinksDirective)(ɵngcc0.ɵɵdirectiveInject(WizardCompletionStep, 1));\n  };\n\n  EnableBackLinksDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: EnableBackLinksDirective,\n    selectors: [[\"\", \"awEnableBackLinks\", \"\"]],\n    outputs: {\n      stepExit: \"stepExit\"\n    }\n  });\n\n  __decorate([Output(), __metadata(\"design:type\", Object)], EnableBackLinksDirective.prototype, \"stepExit\", void 0);\n\n  EnableBackLinksDirective = __decorate([__param(0, Host()), __metadata(\"design:paramtypes\", [WizardCompletionStep])], EnableBackLinksDirective);\n  /**\n   * Checks whether the given `value` implements the interface [[StepId]].\n   *\n   * @param value The value to be checked\n   * @returns True if the given value implements [[StepId]] and false otherwise\n   */\n\n  return EnableBackLinksDirective;\n})();\n\nfunction isStepId(value) {\n  return value.hasOwnProperty('stepId') && !(value instanceof WizardStep);\n}\n/**\n * Checks whether the given `value` implements the interface [[StepIndex]].\n *\n * @param value The value to be checked\n * @returns True if the given value implements [[StepIndex]] and false otherwise\n */\n\n\nfunction isStepIndex(value) {\n  return value.hasOwnProperty('stepIndex');\n}\n/**\n * Checks whether the given `value` implements the interface [[StepOffset]].\n *\n * @param value The value to be checked\n * @returns True if the given value implements [[StepOffset]] and false otherwise\n */\n\n\nfunction isStepOffset(value) {\n  return value.hasOwnProperty('stepOffset');\n}\n/**\n * The `awGoToStep` directive can be used to navigate to a given step.\n * This step can be defined in one of multiple formats\n *\n * ### Syntax\n *\n * With absolute step index:\n *\n * ```html\n * <button [awGoToStep]=\"{ stepIndex: absolute step index }\" (finalize)=\"finalize method\">...</button>\n * ```\n *\n * With unique step id:\n *\n * ```html\n * <button [awGoToStep]=\"{ stepId: 'step id of destination step' }\" (finalize)=\"finalize method\">...</button>\n * ```\n *\n * With a wizard step object:\n *\n * ```html\n * <button [awGoToStep]=\"wizard step object\" (finalize)=\"finalize method\">...</button>\n * ```\n *\n * With an offset to the defining step:\n *\n * ```html\n * <button [awGoToStep]=\"{ stepOffset: offset }\" (finalize)=\"finalize method\">...</button>\n * ```\n *\n * @author Marc Arndt\n */\n\n\nlet GoToStepDirective = /*#__PURE__*/(() => {\n  let GoToStepDirective = class GoToStepDirective {\n    /**\n     * Constructor\n     *\n     * @param wizard The wizard component\n     * @param wizardStep The wizard step, which contains this [[GoToStepDirective]]\n     */\n    constructor(wizard, wizardStep) {\n      this.wizard = wizard;\n      this.wizardStep = wizardStep;\n      /**\n       * This [[EventEmitter]] is called directly before the current step is exited during a transition through a component with this directive.\n       */\n\n      this.preFinalize = new EventEmitter();\n      /**\n       * This [[EventEmitter]] is called directly after the current step is exited during a transition through a component with this directive.\n       */\n\n      this.postFinalize = new EventEmitter();\n    }\n    /**\n     * A convenience field for `preFinalize`\n     */\n\n\n    get finalize() {\n      return this.preFinalize;\n    }\n    /**\n     * A convenience name for `preFinalize`\n     *\n     * @param emitter The [[EventEmitter]] to be set\n     */\n\n\n    set finalize(emitter) {\n      /* istanbul ignore next */\n      this.preFinalize = emitter;\n    }\n    /**\n     * Returns the destination step of this directive as an absolute step index inside the wizard\n     *\n     * @returns The index of the destination step\n     * @throws If `targetStep` is of an unknown type an `Error` is thrown\n     */\n\n\n    get destinationStep() {\n      let destinationStep;\n\n      if (isStepIndex(this.targetStep)) {\n        destinationStep = this.targetStep.stepIndex;\n      } else if (isStepId(this.targetStep)) {\n        destinationStep = this.wizard.getIndexOfStepWithId(this.targetStep.stepId);\n      } else if (isStepOffset(this.targetStep) && this.wizardStep !== null) {\n        destinationStep = this.wizard.getIndexOfStep(this.wizardStep) + this.targetStep.stepOffset;\n      } else if (this.targetStep instanceof WizardStep) {\n        destinationStep = this.wizard.getIndexOfStep(this.targetStep);\n      } else {\n        throw new Error(`Input 'targetStep' is neither a WizardStep, StepOffset, StepIndex or StepId`);\n      }\n\n      return destinationStep;\n    }\n    /**\n     * Listener method for `click` events on the component with this directive.\n     * After this method is called the wizard will try to transition to the `destinationStep`\n     */\n\n\n    onClick() {\n      this.wizard.goToStep(this.destinationStep, this.preFinalize, this.postFinalize);\n    }\n\n  };\n\n  GoToStepDirective.ɵfac = function GoToStepDirective_Factory(t) {\n    return new (t || GoToStepDirective)(ɵngcc0.ɵɵdirectiveInject(WizardComponent), ɵngcc0.ɵɵdirectiveInject(WizardStep, 8));\n  };\n\n  GoToStepDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: GoToStepDirective,\n    selectors: [[\"\", \"awGoToStep\", \"\"]],\n    hostBindings: function GoToStepDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function GoToStepDirective_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n    },\n    inputs: {\n      targetStep: [\"awGoToStep\", \"targetStep\"]\n    },\n    outputs: {\n      preFinalize: \"preFinalize\",\n      postFinalize: \"postFinalize\",\n      finalize: \"finalize\"\n    }\n  });\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], GoToStepDirective.prototype, \"preFinalize\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], GoToStepDirective.prototype, \"postFinalize\", void 0);\n\n  __decorate([Input('awGoToStep'), __metadata(\"design:type\", Object)], GoToStepDirective.prototype, \"targetStep\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter), __metadata(\"design:paramtypes\", [EventEmitter])], GoToStepDirective.prototype, \"finalize\", null);\n\n  __decorate([HostListener('click'), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], GoToStepDirective.prototype, \"onClick\", null);\n\n  GoToStepDirective = __decorate([__param(1, Optional()), __metadata(\"design:paramtypes\", [WizardComponent, WizardStep])], GoToStepDirective);\n  /**\n   * The `awNextStep` directive can be used to navigate to the next step.\n   *\n   * ### Syntax\n   *\n   * ```html\n   * <button awNextStep (finalize)=\"finalize method\">...</button>\n   * ```\n   *\n   * @author Marc Arndt\n   */\n\n  return GoToStepDirective;\n})();\nlet NextStepDirective = /*#__PURE__*/(() => {\n  let NextStepDirective = class NextStepDirective {\n    /**\n     * Constructor\n     *\n     * @param wizard The state of the wizard\n     */\n    constructor(wizard) {\n      this.wizard = wizard;\n      /**\n       * This [[EventEmitter]] is called directly before the current step is exited during a transition through a component with this directive.\n       */\n\n      this.preFinalize = new EventEmitter();\n      /**\n       * This [[EventEmitter]] is called directly after the current step is exited during a transition through a component with this directive.\n       */\n\n      this.postFinalize = new EventEmitter();\n    }\n    /**\n     * A convenience field for `preFinalize`\n     */\n\n\n    get finalize() {\n      return this.preFinalize;\n    }\n    /**\n     * A convenience name for `preFinalize`\n     *\n     * @param emitter The [[EventEmitter]] to be set\n     */\n\n\n    set finalize(emitter) {\n      /* istanbul ignore next */\n      this.preFinalize = emitter;\n    }\n    /**\n     * Listener method for `click` events on the component with this directive.\n     * After this method is called the wizard will try to transition to the next step\n     */\n\n\n    onClick() {\n      this.wizard.goToNextStep(this.preFinalize, this.postFinalize);\n    }\n\n  };\n\n  NextStepDirective.ɵfac = function NextStepDirective_Factory(t) {\n    return new (t || NextStepDirective)(ɵngcc0.ɵɵdirectiveInject(WizardComponent));\n  };\n\n  NextStepDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: NextStepDirective,\n    selectors: [[\"\", \"awNextStep\", \"\"]],\n    hostBindings: function NextStepDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function NextStepDirective_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n    },\n    outputs: {\n      preFinalize: \"preFinalize\",\n      postFinalize: \"postFinalize\",\n      finalize: \"finalize\"\n    }\n  });\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], NextStepDirective.prototype, \"preFinalize\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], NextStepDirective.prototype, \"postFinalize\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter), __metadata(\"design:paramtypes\", [EventEmitter])], NextStepDirective.prototype, \"finalize\", null);\n\n  __decorate([HostListener('click'), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], NextStepDirective.prototype, \"onClick\", null);\n\n  NextStepDirective = __decorate([__metadata(\"design:paramtypes\", [WizardComponent])], NextStepDirective);\n  /**\n   * The `awOptionalStep` directive can be used to define an optional `wizard-step`.\n   * An optional wizard step is a [[WizardStep]] that doesn't need to be completed to transition to later wizard steps.\n   *\n   * ### Syntax\n   *\n   * ```html\n   * <aw-wizard-step awOptionalStep>\n   *     ...\n   * </aw-wizard-step>\n   * ```\n   *\n   * ### Example\n   *\n   * ```html\n   * <aw-wizard-step stepTitle=\"Second step\" awOptionalStep>\n   *     ...\n   * </aw-wizard-step>\n   * ```\n   *\n   * @author Marc Arndt\n   */\n\n  return NextStepDirective;\n})();\nlet OptionalStepDirective = /*#__PURE__*/(() => {\n  let OptionalStepDirective = class OptionalStepDirective {\n    /**\n     * Constructor\n     *\n     * @param wizardStep The wizard step, which contains this [[OptionalStepDirective]]\n     */\n    constructor(wizardStep) {\n      this.wizardStep = wizardStep; // tslint:disable-next-line:no-input-rename\n\n      this.optional = true;\n    }\n    /**\n     * Initialization work\n     */\n\n\n    ngOnInit() {\n      // The input receives '' when specified in the template without a value.  In this case, apply the default value (`true`).\n      this.wizardStep.optional = this.optional || this.optional === '';\n    }\n\n  };\n\n  OptionalStepDirective.ɵfac = function OptionalStepDirective_Factory(t) {\n    return new (t || OptionalStepDirective)(ɵngcc0.ɵɵdirectiveInject(WizardStep, 1));\n  };\n\n  OptionalStepDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: OptionalStepDirective,\n    selectors: [[\"\", \"awOptionalStep\", \"\"]],\n    inputs: {\n      optional: [\"awOptionalStep\", \"optional\"]\n    }\n  });\n\n  __decorate([Input('awOptionalStep'), __metadata(\"design:type\", Object)], OptionalStepDirective.prototype, \"optional\", void 0);\n\n  OptionalStepDirective = __decorate([__param(0, Host()), __metadata(\"design:paramtypes\", [WizardStep])], OptionalStepDirective);\n  /**\n   * The `awPreviousStep` directive can be used to navigate to the previous step.\n   * Compared to the [[NextStepDirective]] it's important to note, that this directive doesn't contain a `finalize` output method.\n   *\n   * ### Syntax\n   *\n   * ```html\n   * <button awPreviousStep>...</button>\n   * ```\n   *\n   * @author Marc Arndt\n   */\n\n  return OptionalStepDirective;\n})();\nlet PreviousStepDirective = /*#__PURE__*/(() => {\n  let PreviousStepDirective = class PreviousStepDirective {\n    /**\n     * Constructor\n     *\n     * @param wizard The state of the wizard\n     */\n    constructor(wizard) {\n      this.wizard = wizard;\n      /**\n       * This [[EventEmitter]] is called directly before the current step is exited during a transition through a component with this directive.\n       */\n\n      this.preFinalize = new EventEmitter();\n      /**\n       * This [[EventEmitter]] is called directly after the current step is exited during a transition through a component with this directive.\n       */\n\n      this.postFinalize = new EventEmitter();\n    }\n    /**\n     * A convenience field for `preFinalize`\n     */\n\n\n    get finalize() {\n      return this.preFinalize;\n    }\n    /**\n     * A convenience field for `preFinalize`\n     *\n     * @param emitter The [[EventEmitter]] to be set\n     */\n\n\n    set finalize(emitter) {\n      /* istanbul ignore next */\n      this.preFinalize = emitter;\n    }\n    /**\n     * Listener method for `click` events on the component with this directive.\n     * After this method is called the wizard will try to transition to the previous step\n     */\n\n\n    onClick() {\n      this.wizard.goToPreviousStep(this.preFinalize, this.postFinalize);\n    }\n\n  };\n\n  PreviousStepDirective.ɵfac = function PreviousStepDirective_Factory(t) {\n    return new (t || PreviousStepDirective)(ɵngcc0.ɵɵdirectiveInject(WizardComponent));\n  };\n\n  PreviousStepDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: PreviousStepDirective,\n    selectors: [[\"\", \"awPreviousStep\", \"\"]],\n    hostBindings: function PreviousStepDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function PreviousStepDirective_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n    },\n    outputs: {\n      preFinalize: \"preFinalize\",\n      postFinalize: \"postFinalize\",\n      finalize: \"finalize\"\n    }\n  });\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], PreviousStepDirective.prototype, \"preFinalize\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], PreviousStepDirective.prototype, \"postFinalize\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter), __metadata(\"design:paramtypes\", [EventEmitter])], PreviousStepDirective.prototype, \"finalize\", null);\n\n  __decorate([HostListener('click'), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], PreviousStepDirective.prototype, \"onClick\", null);\n\n  PreviousStepDirective = __decorate([__metadata(\"design:paramtypes\", [WizardComponent])], PreviousStepDirective);\n  /**\n   * The `awResetWizard` directive can be used to reset the wizard to its initial state.\n   * This directive accepts an output, which can be used to specify some custom cleanup work during the reset process.\n   *\n   * ### Syntax\n   *\n   * ```html\n   * <button awResetWizard (finalize)=\"custom reset task\">...</button>\n   * ```\n   *\n   * @author Marc Arndt\n   */\n\n  return PreviousStepDirective;\n})();\nlet ResetWizardDirective = /*#__PURE__*/(() => {\n  let ResetWizardDirective = class ResetWizardDirective {\n    /**\n     * Constructor\n     *\n     * @param wizard The wizard component\n     */\n    constructor(wizard) {\n      this.wizard = wizard;\n      /**\n       * An [[EventEmitter]] containing some tasks to be done, directly before the wizard is being reset\n       */\n\n      this.finalize = new EventEmitter();\n    }\n    /**\n     * Resets the wizard\n     */\n\n\n    onClick() {\n      // do some optional cleanup work\n      this.finalize.emit(); // reset the wizard to its initial state\n\n      this.wizard.reset();\n    }\n\n  };\n\n  ResetWizardDirective.ɵfac = function ResetWizardDirective_Factory(t) {\n    return new (t || ResetWizardDirective)(ɵngcc0.ɵɵdirectiveInject(WizardComponent));\n  };\n\n  ResetWizardDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ResetWizardDirective,\n    selectors: [[\"\", \"awResetWizard\", \"\"]],\n    hostBindings: function ResetWizardDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function ResetWizardDirective_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n    },\n    outputs: {\n      finalize: \"finalize\"\n    }\n  });\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], ResetWizardDirective.prototype, \"finalize\", void 0);\n\n  __decorate([HostListener('click'), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], ResetWizardDirective.prototype, \"onClick\", null);\n\n  ResetWizardDirective = __decorate([__metadata(\"design:paramtypes\", [WizardComponent])], ResetWizardDirective);\n  /**\n   * The `awSelectedStep` directive can be used on a [[WizardStep]] to set it as selected after the wizard initialisation or a reset.\n   *\n   * ### Syntax\n   *\n   * ```html\n   * <aw-wizard-step stepTitle=\"Step title\" awSelectedStep>\n   *     ...\n   * </aw-wizard-step>\n   * ```\n   *\n   * @author Marc Arndt\n   */\n\n  return ResetWizardDirective;\n})();\nlet SelectedStepDirective = /*#__PURE__*/(() => {\n  let SelectedStepDirective = class SelectedStepDirective {\n    /**\n     * Constructor\n     *\n     * @param wizardStep The wizard step, which should be selected by default\n     */\n    constructor(wizardStep) {\n      this.wizardStep = wizardStep;\n    }\n    /**\n     * Initialization work\n     */\n\n\n    ngOnInit() {\n      this.wizardStep.defaultSelected = true;\n    }\n\n  };\n\n  SelectedStepDirective.ɵfac = function SelectedStepDirective_Factory(t) {\n    return new (t || SelectedStepDirective)(ɵngcc0.ɵɵdirectiveInject(WizardStep, 1));\n  };\n\n  SelectedStepDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: SelectedStepDirective,\n    selectors: [[\"\", \"awSelectedStep\", \"\"]]\n  });\n  SelectedStepDirective = __decorate([__param(0, Host()), __metadata(\"design:paramtypes\", [WizardStep])], SelectedStepDirective);\n  return SelectedStepDirective;\n})();\nvar WizardCompletionStepDirective_1;\n/**\n * The `awWizardCompletionStep` directive can be used to define a completion/success step at the end of your wizard\n * After a [[WizardCompletionStep]] has been entered, it has the characteristic that the user is blocked from\n * leaving it again to a previous step.\n * In addition entering a [[WizardCompletionStep]] automatically sets the `wizard`, and all steps inside the `wizard`,\n * as completed.\n *\n * ### Syntax\n *\n * ```html\n * <div awWizardCompletionStep [stepTitle]=\"title of the wizard step\"\n *    [navigationSymbol]=\"{ symbol: 'navigation symbol', fontFamily: 'font-family' }\"\n *    (stepEnter)=\"event emitter to be called when the wizard step is entered\"\n *    (stepExit)=\"event emitter to be called when the wizard step is exited\">\n *    ...\n * </div>\n * ```\n *\n * ### Example\n *\n * ```html\n * <div awWizardCompletionStep stepTitle=\"Step 1\" [navigationSymbol]=\"{ symbol: '1' }\">\n *    ...\n * </div>\n * ```\n *\n * With a navigation symbol from the `font-awesome` font:\n *\n * ```html\n * <div awWizardCompletionStep stepTitle=\"Step 1\" [navigationSymbol]=\"{ symbol: '&#xf1ba;', fontFamily: 'FontAwesome' }\">\n *    ...\n * </div>\n * ```\n *\n * @author Marc Arndt\n */\n\nlet WizardCompletionStepDirective = WizardCompletionStepDirective_1 = class WizardCompletionStepDirective extends WizardCompletionStep {};\n\nWizardCompletionStepDirective.ɵfac = /*@__PURE__*/function () {\n  let ɵWizardCompletionStepDirective_BaseFactory;\n  return function WizardCompletionStepDirective_Factory(t) {\n    return (ɵWizardCompletionStepDirective_BaseFactory || (ɵWizardCompletionStepDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(WizardCompletionStepDirective)))(t || WizardCompletionStepDirective);\n  };\n}();\n\nWizardCompletionStepDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: WizardCompletionStepDirective,\n  selectors: [[\"\", \"awWizardCompletionStep\", \"\"]],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: WizardStep,\n    useExisting: forwardRef(() => WizardCompletionStepDirective_1)\n  }, {\n    provide: WizardCompletionStep,\n    useExisting: forwardRef(() => WizardCompletionStepDirective_1)\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n});\nvar WizardStepDirective_1;\n/**\n * The `awWizardStep` directive can be used to define a normal step inside a wizard.\n *\n * ### Syntax\n *\n * With `stepTitle` and `navigationSymbol` inputs:\n *\n * ```html\n * <div awWizardStep [stepTitle]=\"step title\" [navigationSymbol]=\"{ symbol: 'symbol', fontFamily: 'font-family' }\"\n *    [canExit]=\"deciding function\" (stepEnter)=\"enter function\" (stepExit)=\"exit function\">\n *    ...\n * </div>\n * ```\n *\n * With `awWizardStepTitle` and `awWizardStepSymbol` directives:\n *\n * ```html\n * <div awWizardStep [canExit]=\"deciding function\" (stepEnter)=\"enter function\" (stepExit)=\"exit function\">\n *    <ng-template awWizardStepTitle>\n *        step title\n *    </ng-template>\n *    <ng-template awWizardStepSymbol>\n *        symbol\n *    </ng-template>\n *    ...\n * </div>\n * ```\n *\n * ### Example\n *\n * With `stepTitle` and `navigationSymbol` inputs:\n *\n * ```html\n * <div awWizardStep stepTitle=\"Address information\" [navigationSymbol]=\"{ symbol: '&#xf1ba;', fontFamily: 'FontAwesome' }\">\n *    ...\n * </div>\n * ```\n *\n * With `awWizardStepTitle` and `awWizardStepSymbol` directives:\n *\n * ```html\n * <div awWizardStep>\n *    <ng-template awWizardStepTitle>\n *        Address information\n *    </ng-template>\n *    <ng-template awWizardStepSymbol>\n *        <i class=\"fa fa-taxi\"></i>\n *    </ng-template>\n * </div>\n * ```\n *\n * @author Marc Arndt\n */\n\nlet WizardStepDirective = WizardStepDirective_1 = class WizardStepDirective extends WizardStep {};\n\nWizardStepDirective.ɵfac = /*@__PURE__*/function () {\n  let ɵWizardStepDirective_BaseFactory;\n  return function WizardStepDirective_Factory(t) {\n    return (ɵWizardStepDirective_BaseFactory || (ɵWizardStepDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(WizardStepDirective)))(t || WizardStepDirective);\n  };\n}();\n\nWizardStepDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: WizardStepDirective,\n  selectors: [[\"\", \"awWizardStep\", \"\"]],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: WizardStep,\n    useExisting: forwardRef(() => WizardStepDirective_1)\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n});\n/**\n * The [[awNavigationMode]] directive can be used to customize wizard'd navigation mode.\n *\n * There are several usage options:\n *\n * ### Option 1. Customize the default navigation mode with [[navigateBackward]] and/or [[navigateForward]] inputs.\n *\n * ```html\n * <aw-wizard [awNavigationMode] navigateBackward=\"deny\" navigateForward=\"allow\">...</aw-wizard>\n * ```\n *\n * ### Option 2. Pass in a custom navigation mode\n *\n * ```typescript\n * import { BaseNavigationMode } from 'angular-archwizard'\n *\n * class CustomNavigationMode extends BaseNavigationMode {\n *\n *   // ...\n * }\n * ```\n *\n * ```typescript\n * @Component({\n *   // ...\n * })\n * class MyComponent {\n *\n *   navigationMode = new CustomNavigationMode();\n * }\n * ```\n *\n * ```html\n * <aw-wizard [awNavigationMode]=\"navigationMode\">...</aw-wizard>\n * ```\n *\n * ### Additional Notes\n *\n * - Specifying a custom navigation mode takes priority over [[navigateBackward]] and [[navigateForward]] inputs\n *\n * - Omitting the [[awNavigationMode]] directive or, equally, specifying just [[awNavigationMode]] without\n *   any inputs or parameters causes the wizard to use the default \"strict\" navigation mode equivalent to\n *\n * ```html\n * <aw-wizard [awNavigationMode] navigateBackward=\"deny\" navigateForward=\"allow\">...</aw-wizard>\n * ````\n */\n\nlet NavigationModeDirective = /*#__PURE__*/(() => {\n  let NavigationModeDirective = class NavigationModeDirective {\n    constructor(wizard) {\n      this.wizard = wizard;\n    }\n\n    ngOnChanges(changes) {\n      this.wizard.navigation = this.getNavigationMode();\n    }\n\n    getNavigationMode() {\n      if (this.awNavigationMode) {\n        return this.awNavigationMode;\n      }\n\n      return new ConfigurableNavigationMode(this.navigateBackward, this.navigateForward);\n    }\n\n  };\n\n  NavigationModeDirective.ɵfac = function NavigationModeDirective_Factory(t) {\n    return new (t || NavigationModeDirective)(ɵngcc0.ɵɵdirectiveInject(WizardComponent));\n  };\n\n  NavigationModeDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: NavigationModeDirective,\n    selectors: [[\"\", \"awNavigationMode\", \"\"]],\n    inputs: {\n      awNavigationMode: \"awNavigationMode\",\n      navigateBackward: \"navigateBackward\",\n      navigateForward: \"navigateForward\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n\n  __decorate([Input(), __metadata(\"design:type\", Object)], NavigationModeDirective.prototype, \"awNavigationMode\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], NavigationModeDirective.prototype, \"navigateBackward\", void 0);\n\n  __decorate([Input(), __metadata(\"design:type\", String)], NavigationModeDirective.prototype, \"navigateForward\", void 0);\n\n  NavigationModeDirective = __decorate([__metadata(\"design:paramtypes\", [WizardComponent])], NavigationModeDirective);\n  /**\n   * The `awCompletedStep` directive can be used to make a wizard step initially completed.\n   *\n   * Initially completed steps are shown as completed when the wizard is presented to the user.\n   *\n   * A typical use case is to make a step initially completed if it is automatically filled with some derived/predefined information.\n   *\n   * ### Syntax\n   *\n   * ```html\n   * <aw-wizard-step awCompletedStep>\n   *     ...\n   * </aw-wizard-step>\n   * ```\n   *\n   * An optional boolean condition can be specified:\n   *\n   * ```html\n   * <aw-wizard-step [awCompletedStep]=\"shouldBeCompleted\">\n   *     ...\n   * </aw-wizard-step>\n   * ```\n   *\n   * ### Example\n   *\n   * ```html\n   * <aw-wizard-step stepTitle=\"First step\" [awCompletedStep]=\"firstStepPrefilled\">\n   *     ...\n   * </aw-wizard-step>\n   * ```\n   */\n\n  return NavigationModeDirective;\n})();\nlet CompletedStepDirective = /*#__PURE__*/(() => {\n  let CompletedStepDirective = class CompletedStepDirective {\n    /**\n     * Constructor\n     *\n     * @param wizardStep The wizard step, which contains this [[CompletedStepDirective]]\n     */\n    constructor(wizardStep) {\n      this.wizardStep = wizardStep; // tslint:disable-next-line:no-input-rename\n\n      this.initiallyCompleted = true;\n    }\n    /**\n     * Initialization work\n     */\n\n\n    ngOnInit() {\n      // The input receives '' when specified in the template without a value.  In this case, apply the default value (`true`).\n      this.wizardStep.initiallyCompleted = this.initiallyCompleted || this.initiallyCompleted === '';\n    }\n\n  };\n\n  CompletedStepDirective.ɵfac = function CompletedStepDirective_Factory(t) {\n    return new (t || CompletedStepDirective)(ɵngcc0.ɵɵdirectiveInject(WizardStep, 1));\n  };\n\n  CompletedStepDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: CompletedStepDirective,\n    selectors: [[\"\", \"awCompletedStep\", \"\"]],\n    inputs: {\n      initiallyCompleted: [\"awCompletedStep\", \"initiallyCompleted\"]\n    }\n  });\n\n  __decorate([Input('awCompletedStep'), __metadata(\"design:type\", Object)], CompletedStepDirective.prototype, \"initiallyCompleted\", void 0);\n\n  CompletedStepDirective = __decorate([__param(0, Host()), __metadata(\"design:paramtypes\", [WizardStep])], CompletedStepDirective);\n  return CompletedStepDirective;\n})();\nvar ArchwizardModule_1;\n/**\n * The module defining all the content inside `angular-archwizard`\n *\n * @author Marc Arndt\n */\n\nlet ArchwizardModule = ArchwizardModule_1 = class ArchwizardModule {\n  /* istanbul ignore next */\n  static forRoot() {\n    return {\n      ngModule: ArchwizardModule_1,\n      providers: [// Nothing here yet\n      ]\n    };\n  }\n\n};\n\nArchwizardModule.ɵfac = function ArchwizardModule_Factory(t) {\n  return new (t || ArchwizardModule)();\n};\n\nArchwizardModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: ArchwizardModule\n});\nArchwizardModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n  imports: [[CommonModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ArchwizardModule, {\n    declarations: function () {\n      return [WizardComponent, WizardStepComponent, WizardNavigationBarComponent, WizardCompletionStepComponent, GoToStepDirective, NextStepDirective, PreviousStepDirective, OptionalStepDirective, WizardStepSymbolDirective, WizardStepTitleDirective, EnableBackLinksDirective, WizardStepDirective, WizardCompletionStepDirective, SelectedStepDirective, ResetWizardDirective, NavigationModeDirective, CompletedStepDirective];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [WizardComponent, WizardStepComponent, WizardNavigationBarComponent, WizardCompletionStepComponent, GoToStepDirective, NextStepDirective, PreviousStepDirective, OptionalStepDirective, WizardStepSymbolDirective, WizardStepTitleDirective, EnableBackLinksDirective, WizardStepDirective, WizardCompletionStepDirective, SelectedStepDirective, ResetWizardDirective, NavigationModeDirective, CompletedStepDirective];\n    }\n  });\n})(); // export the components\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ArchwizardModule, BaseNavigationMode, CompletedStepDirective, ConfigurableNavigationMode, EnableBackLinksDirective, GoToStepDirective, MovingDirection, NavigationModeDirective, NextStepDirective, OptionalStepDirective, PreviousStepDirective, ResetWizardDirective, SelectedStepDirective, WizardCompletionStep, WizardCompletionStepComponent, WizardCompletionStepDirective, WizardComponent, WizardNavigationBarComponent, WizardStep, WizardStepComponent, WizardStepDirective, WizardStepSymbolDirective, WizardStepTitleDirective, isStepId, isStepIndex, isStepOffset }; //# sourceMappingURL=angular-archwizard.js.map","map":null,"metadata":{},"sourceType":"module"}